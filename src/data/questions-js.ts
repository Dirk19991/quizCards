import { Question } from './questions';

export const questionsJs: Question[] = [
  {
    'Цикл "for...of" используется для перебора значений итерируемого объекта, таких как массивы, строки, Map и Set. "for...in" используется для перебора свойств объекта':
      'В чем отличие for...in и for...of',
  },
  {
    'try {...} catch {...}, try {...} finally {...}, try {...} catch {...} finally {...}': `Какие есть три основные формы конструкции try?`,
  },
  {
    'он допускает отрицательную позицию. Если pos – отрицательное число, то отсчет ведется от конца строки.': `В чем преимущество метода str.at(pos)?`,
  },
  {
    'let promise = new Promise(function(resolve, reject) { }': `Как вызвать промис?`,
  },
  {
    '"pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.': `какие есть состояния у промиса? `,
  },
  {
    'вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).': `каким может быть свойство result у промиса?`,
  },
  {
    'Нет, они ожидают только один аргумент (или ни одного). Все дополнительные аргументы будут проигнорированы. ': `можно ли в resolve/reject промиса передать больше одного аргумента?`,
  },
  {
    'объект подобный промису (имеющий метод then). Можно написать самому или встретить в какой-то библиотеке. Все промисы - thenable, но не все thenable - промисы': `что такое thenable?`,
  },
  {
    'встроенный объект, используемый для обработки асинхронных операций. ': `что такое промис?`,
  },
  {
    'да. Первый аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат. Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.': `можно ли в then передать два аргумента?`,
  },
  {
    'да. Первый аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат. Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.': `можно ли в then передать два аргумента?`,
  },
  {
    'он выполняется синхронно после всех изменений в DOM, но перед тем, как браузер отрисует изменения.': `в чем главная особенность useLayoutEffect?`,
  },
  {
    'writable – можно ли свойство можно изменить, enumerable – перечисляется ли в циклах, configurable – можно ли свойство удалить, а эти атрибуты изменять': `какие флаги свойств бывают в JS?`,
  },
  {
    'нет, более того configurable: false не даст изменить и остальные флаги свойства, а также не даст его удалить': `можно ли свойство сделать из некофигурируемого конфигурируемым?`,
  },
  {
    'Object.getOwnPropertyDescriptor(obj, propertyName)': `какой метод позволяет получить полную информаци о свойстве объекта?`,
  },
  {
    'Object.defineProperty(obj, propertyName, descriptor)': `какой метод нужно использовать чтобы изменить флаги свойства?`,
  },
  {
    'Object.preventExtensions(obj)': `Какой метод запрещает добавлять новые свойства в объект?
    `,
  },
  {
    'Object.freeze(obj)': `Какой метод запрещает добавлять/удалять/изменять свойства и устанавливает configurable: false, writable: false для всех существующих свойств?
    `,
  },
  {
    'Например, можно использовать геттеры/сеттеры как обёртки над «реальными» значениями свойств': `Что делать, если мы хотим запретить устанавливать короткое имя для объекта user?`,
  },
  {
    'Yes. That means myArray[3] is the same as myArray["3"] because all keys, if not already strings, are coerced into strings because all JavaScript object keys are strings.': `Are all keys in JavaScript objects strings?`,
  },
  {
    'Использовать квадратные скобки, например  [fruit]: 5': `Как сделать в объекте вычисляемое свойство? Например, получать его из промпта?
    `,
  },
  {
    'Может быть такое, что значение какого-то свойства равно undefined, тогда in отработает нормально, а проверка с undefined - нет': `В чем отличие проверки "key" in object от user.noSuchProperty === undefined для определения есть ли свойство в объекте?`,
  },
  {
    'Целочисленные - по возрастанию, остальные - в порядке создания': `Как упорядочены свойства объекта для перебора?`,
  },

  {
    'let clone = Object.assign({}, user)': `Как клонировать объект с помощью Object.assign?`,
  },
  {
    'Если не брать внешние библиотеки, в современных браузерах поддерживается метод structuredClone. Если в объекте нет ничего сложного, то JSON.parse(JSON.stringify(x)), но structuredClone работает с датами, мапами, сетами (но не с функциями, с функциями вообще пока непонятно что использовать)': `Как лучше сделать глубокое копирование объекта?`,
  },
];
